# Assignment #08. 5장. 구부러지거나 부러지거나.

**오늘 TIL 3줄 요약**
- 소프트웨어의 구조는 유연해야 한다.
- 되돌릴 수 있는 의사 결정을 내리자.
- 코드를 재사용할 수 있다는 생각을 하며 코드의 결합도를 낮추자. 직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 유지하자. 

**TIL(Today I Learned) 날짜**
- 2022.03.27

**오늘 읽은 범위**
- 5장. 구부러지거나 부러지거나

**책에서 기억하고 싶은 내용을 써 보세요.**

# 구부러지거나 부러지거나
- 현대의 빠른 변화 속도를 따라가려면 가능한 한 느슨하고 유연한 코드를 작성해야 한다.
- **되돌릴 수 있는** 의사 결정을 내리는 구체적인 방법에 대해 알아보자.
- 유연함을 유지하는 한 가지 좋은 방법은 물론 가능한 한 코드를 적게 작성하는 것이다.

# Topic 28. 결합도 줄이기
> 우리가 어떤 것 하나만을 골라내려고 해도, 그것이 우주의 다른 모든 것과 얽혀 있음을 깨닫게 된다.

- 높은 결합도는 변경의 적이다.
- 소프트웨어의 구조는 유연해야 한다. 각각의 부품이 다른 부품에 가능한 한 조금만 연결되어야 한다.

### Tip 44. 결합도가 낮은 코드가 바꾸기 쉽다.

- 다음 규칙을 따라야 한다:
	1. 열차 사고(train wreck): 연쇄 메서드 호출
	2. 글로벌화: 정적인(static) 것의 위험함
	3. 상속: 왜 클래스 상속이 위험한가?

- 이후 내용에서 근본적인 패턴을 찾아보고, 여러분의 코드에 적용해야 한다.
- "결합"의 증상을 놓치지 않도록 주의하자:
	1. 관계 없는 모듈이나 라이브러리 간의 희한한 의존 관계
	2. 한 모듈의 '간단한' 수정이 이와 관계 없는 모듈을 통해 시스템 전역으로 퍼져 나가거나 시스템의 다른 곳에서 무언가를 깨뜨리는 경우
	3. 개발자가 수정하는 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우
	4. 변경 사항에 누가 영향을 받는지 파악하고 있는 사람이 없어 결국 모든 사람이 참석해야 하는 회의

## 열차 사고

- 다음 코드를 보자:
```java
public void applyDiscount(customer, orderId, discount) {
	totals = customer.orders.find(orderId).getTotals();
	totals.grandTotal = totals.grandTotal - discount;
	totals.discount = discount;
}
```
- 코드를 쓰거나 이해하기 위해 알아야 하는 것이 너무 많다.
- 코드를 계속 사용하기 위해서 앞으로 바꾸면 안 되는 것도 너무 많다.
- 기차의 모든 객차가 서로 연결되어 있듯 메서드, 속성이 모두 연결되어 있다.

### Tip 45. 묻지 말고 말하라 (Tell, Don't Ask, TDA)

- TDA 원칙이란?
	- 다른 객체의 내부 상태에 따라 판단을 내리고 객체를 갱신해서는 안 된다는 것이다.
	- 캡슐화의 장점은 사라진다.

- 위 코드 수정 방법: 
	1. totals 객체에 할인 처리를 위임한다.
	```java
	public void applyDiscount(customer, orderId, discount) {
		customer
			.orders
			.find(orderId)
			.getTotals()
			.applyDiscount(discount);
	}
	```
	
	2. customer 객체에도 동일하게 TDA 원칙을 적용해야 한다: 주문 컬렉션을 가져와서 주문을 찾아서는 안 된다. 고객 객체에서 바로 주문 객체를 얻어와야 한다.
	```java
	public void applyDiscount(customer, orderId, discount) {
		customer
			.findOrder(orderId)
			.getTotals()
			.applyDiscount(discount);
	}
	```
	
	3. 주문 객체, 합계에도 적용할 수 있다. 
	```java
	public void applyDiscount(customer, orderId, discount) {
		customer
			.findOrder(orderId)
			.applyDiscount(discount);
	}
	```

- TDA는 자연 법칙이 아니다.
- 모든 애플리케이션에는 보편적인 최상위 개념이 있다: 위 예시에서는 '고객'과 '주문'이 최상위 개념이다.

## 데메테르 법칙
- LoD(Law of Dementer)
	- 프로젝트를 수행하는 도중 개발자들에게 보다 깨끗하고 결합도가 낮은 함수를 작성하는 방법
	- 어떤 클래스 C에 정의된 메서드가 다음 목록에 속하는 것만 사용할 수 있다고 제한한다:
		- C의 다른 인스턴스 메서드
		- 메서드의 매개 변수
		- 스택이나 힙에 자신이 생성하는 객체의 메서드
		- 전역 변수
- But, LoD의 가치는 빛이 바라고 오래 되었다. 
- 그럼에도 불구하고 기반이 되는 원칙 자체는 유효하다:

### Tip 46. 메서드 호출을 엮지 말라.
- 무언가에 접근할 때 "."을 딱 하나만 쓰려고 노력해 보라.
- 좋지 않은 예시:
```java
amount = customer.orders.last().totals().amount;

orders = customer.orders;
last = orders.last();
totals = last.totals();
amount = totals.amount();
```
- 단, 엮는 것들이 절대로 바뀌지 않을 것 같다면 이 규칙을 지키지 않아도 된다.

## 연쇄와 파이프라인
- 함수를 조합하여 파이프라인을 만드는 방법: p.207 <Topic 30. 변환 프로그래밍>
- 파이프라인
	- 함수에서 함수로 데이터를 넘겨가며 데이터를 변환
	- But, 파이프라인이 결합을 하나도 만들지 않는 것은 아니다.

## 글로벌화의 해악
- 전역 데이터는 모든 메서드 안에서 사용할 수 있다.
- 전역 데이터의 단점
	- 코드의 결합도를 높인다.
	- 시스템 코드 전체의 영향을 줄 수 있다.
	- 코드를 떼어내는 경우에도 문제를 만든다.

- 코드를 재사용할 수 있도록 해야 한다는 생각이 코딩 습관의 일부가 되어야 한다.

### Tip 47. 전역 데이터를 피하라.	

### 싱글턴(singleton)도 전역 데이터다
- 전역 변수가 아니라 **전역 데이터**라고 말했다.
- 싱글턴 또한 전역 데이터다.
- 그나마 데이터를 메서드로 숨기는 게 낫다.

### 외부 리소스도 전역 데이터다
- 수정 가능한 외부 리소스는 모두 전역 데이터다.
- 해법은 반드시 이 리소스들을 여러분이 작성하는 코드로 모두 감싸는 것이다.

### Tip 48. 전역적이어야 할 만큼 중요하다면 API로 감싸라.

## 상속은 결합을 늘린다.
- p.224 <Topic 31. 상속세>를 참고하라.

## 결국은 모두 ETC
- 결합된 코드는 바꾸기 힘들다.
- 직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라.

# Topic 29. 실세계를 갖고 저글링하기
- 반응적인(responsive) 애플리케이션을 작성하는 법

## 이벤트
- 이벤트: 정보가 있다는 것을 의미
- 이벤트에 잘 반응하는 애플리케이션 만드는 방법:
	1. 유한 상태 기계
	2. 감시자(observer) 패턴
	3. 게시-구독
	4. 반응형 프로그래밍과 스트림

## 유한 상태 기계
- FSM(Finite State Machine): 유한 상태 기계
- 상태를 외부 저장소에 저장하면서 상태 기계를 동작시키면 작업 흐름이 필요한 요구 사항을 수월하게 처리할 수 있을 것이다.

### 상태 기계는 시작일 뿐
- 적용할 수 있는 곳을 찾아보면 좋겠다.
- 그러나 이벤트와 관련된 모든 문제를 해결하지는 못한다.

## 감시자 패턴
- 감시 대상(observable): 이벤트를 발생
- 감시자: 이벤트에 관심이 있는 클라이언트
- 동작 방법
	1. 감시자는 자신이 관심 있는 이벤트를 감시 대상에 등록한다.
	2. 해당 이벤트 발생시 감시 대상은 감시자 목록을 보며 함수를 일일이 호출한다.
	3. 발생한 이벤트를 감시자 함수의 인자로 넘긴다.

- 문제점
	- 모든 감시자가 감시 대상에 등록을 해야 하기 때문에 '결합'이 생긴다.
	- 동기적 처리의 특성상 병목 현상이 발생할 수 있다.

## 게시-구독(publish-subscribe) 
- 발행-구독 모델 => 줄여서 펍섭(pubsub)이라고도 부름
- 감시자 패턴을 일반화: 감시자 패턴에서 발생한 문제를 해결할 수 있음

- 게시자, 구독자 모두 '채널'로 연결된다.
	- 채널은 이름을 가지고 있다.
	- 구독자: 관심사를 하나 이상의 채널에 등록
	- 게시자: 채널에 이벤트를 보낸다.

- 주로 클라우드 서비스가 게시-구독 서비스를 제공한다.
- 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋은 기술이다.

- 단점: 게시-구독 모델을 아주 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기 힘들다.
- 공통 인터페이스인 '채널'을 추상화함으로서 결합도를 줄인다.
- 이벤트 처리에 시간 차원을 추가하는 방법을 알아보자.

## 반응형 프로그래밍과 스트림 그리고 이벤트
- 값이 바뀌면 그 값을 사용하는 다른 값이 '반응(react)'한다.
- 브라우저 세계에서의 리액트(React), 뷰(View)
- 스트림(stream)
	- 이벤트의 리스트를 다룬다.
	- 익숙한 방식으로 스트림을 다룰 수 있다. 
	
- 예제:
```javascript
import * as Observable from 'rxjs'
import { logValues } from '../rxcommon/logger.js'

let animals = Observable.of("ant", "bee", "cat", "dog", "elk");
let ticker = Observable.interval(500)

let combined = Observable.zip(animals, ticker)
combined.subscribe(next => logValues(JSON.stringify(next)))
```
- 두 개의 스트림을 받아 하나로 엮는다.
- 둘 모두 데이터가 있을 때만 엮인 스트림에 결과가 생긴다=출력 스트림은 0.5초에 한 번씩 결과를 내보낸다.
	
- 일반적으로 이벤트 스트림은 이벤트가 발생할 때마다 채워진다.
- 이벤트를 발생시키는 감시 대상들을 병렬적으로 실행시킬 수 있다.

### 이벤트 스트림은 비동기 컬렉션
- 정말 강력한 추상화
- 이벤트 스트림은 동기적 처리와 비동기적 처리를 하나의 편리한 공통 API로 감싸서 통합한다.

## 어디에나 이벤트가 있다.
- 이벤트는 모든 곳에 있다.
- 이벤트가 어디서 발생하든 이벤트를 중심으로 공들여 만든 코드는 일직선으로 수행되는 코드보다 더 잘 반응하고 결합도가 더 낮다.

# Topic 30. 변환 프로그래밍
- 모든 프로그램은 데이터를 변환한다.
- 설계를 고민할 때 변환을 만드는 것에 대해서 생각해보자.
- 프로그램이란 입력을 출력으로 바꾸는 것이라는 사고방식으로 돌아갈 필요가 있다.

### Tip 49. 프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다.

## 변환 찾기
- 요구 사항에서 시작하는 게 변환을 찾는 가장 쉬운 방법
- 하향식 접근 방식: 입력을 출력으로 바꿔 가는 단계를 찾음

### |> 연산자는 무엇이고 왜 쓰는가?
- in 엘릭서
- 순방향 파이프(forward pipe) or 파이프: 파이프라인 연산자

### X 언어에는 파이프라인이 없는데요
- 변환 프로그래밍은 설계 철학에 가까워서...
- 주로 사용자가 많지 않은 언어에서만 쓰임
- 널리 쓰이는 단어들은 대부분 아직 이런 개념들을 지원하지 않고 있다.

- 변환으로 코드를 구성하면 된다.
```javascript
const content = File.read(file_name);
const lines = find_matching_lines(content, pattern);
const result = truncate_lines(line);
```

### Tip 50. 상태를 쌓아 놓지 말고 전달하라.

- 변환 모델에서는.. 데이터를 거대한 강으로, '흐름'으로 생각한다.
- 데이터는 기능과 동등해진다.
- 객체 지향 방식의 지휘 및 통제보다 관리하기 월씬 쉽다.

## 오류 처리는 어떻게 하나?
- 기본적인 관례: 변환 사이에 값을 절대 날것으로 넘기지 않는다. 래퍼(Wrapper)
- 코드 작성 방식: 오류 검사를 변환 안에서 하는 방식 / 변환 바깥에서 하는 방식

### 표현 방식 정하기
- 보통 엘릭서에서는 {:ok, 값} / {:error, 오류} 튜플로 사용한다.

### 각 변환 내에서 오류 처리하기
- 각 변환에서 :ok로 받은 값 / :error로 받은 값에 대한 실행을 달리 한다.
	- ex) :ok일 경우 find_matching_lines({:ok, content}, pattern) do: 실행
	- ex) :error일 경우 find_matching_lines(error, _) do: error

### 파이프라인에서 오류 처리하기
- 쇼트 서킷(short circuit): 결과가 이미 정해져서 더 이상의 코드 실행이 불필요한 경우 이후의 코드 실행을 건너 뛰는 것
- 함수 호출을 나중에 호출할 수 있는 값 형태로 바꾸어야 한다.
	- ex) and_then({:ok, value}, func),   do:func.(value)
		  and_then(anything_else, _func), do: anything_else

## 변환은 프로그래밍을 변환한다.
- 코드를 일련의 변환으로 생각하는 접근 방식은 프로그래밍을 해방시킨다.
- 한번 해 보자.

**오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어 보세요.**

- 새삼스럽게 시대는 계속 변함을 느낀다. 예전에는 가장 중요하다고 했다던 LoD가 이제는 별로 쓸모가 없어졌다던가.
- 개발을 할 때 처음 접했던 단어가 java였고 객체 지향적인 것이 좋다고 했었다. 이번 장을 보면서 느꼈는데, 나는 그때 배웠던 것을 무의식적으로 따르고 있었던 것 같다. 객체 지향적인 구조를 짜려고 노력했고, 결합도가 높은 코드를 보며 상속이 잘 되어 있다고 생각했다. 
- 빠르게 변화하는 물결에 맞춰 가려면 나 또한 계속적으로 발전을 해야함을, 나의 생각에 대해 경각심을 가지게 된 하루였다.

**궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어 보세요.**

- 결합도: 코드 조각 간의 의존 정도
- 열차 사고: 단순 열차 사고인 줄 알았는데, "엉망진창"이라는 뜻도 있다.
- TDA.. 부분을 읽었는데 이해가 안 된다. 결정을 위임을 한다는 의미와 다른 의미인가?
- FSM: 어려워서 유니티를 예시로 한 FSM 실제 개념과 사용 방법에 대한 링크를 찾아보았다: https://boycoding.tistory.com/262

**오늘 읽은 다른 사람의 TIL**
- 
