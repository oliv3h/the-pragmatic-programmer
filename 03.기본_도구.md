# Assignment #05. 3장. 기본도구

**오늘 TIL 3줄 요약**
- 도구들은 제각기 고유의 방식으로 다듬어야 한다.
- 도구들은 각자의 방식으로 유창하게끔(fluency) 손에 익혀야 한다.
- 항상 '분명 더 나은 방법'에 대해 고민하라.

**TIL(Today I Learned) 날짜**
- 2022.03.24

**오늘 읽은 범위**
- 3장. 기본도구

**책에서 기억하고 싶은 내용을 써 보세요.**

# 기본 도구
- 도구들은 제각기 고유의 방식으로 다듬어야 하고, 고유의 방식으로 손에 쥐어야 한다.
- 도구는 우리의 재능을 증폭한다. 
- 일반적으로 사용하는 기본 도구들로 시작하라.
- 기존 도구들로 해결할 수 없다면 도움이 될 만한 다른 것이나 더 강력한 것을 찾아보야아 한다는 것을 명심하자.
- 도구들의 사용법을 배우는 데에 시간을 투자하라.

# Topic 16. 일반 텍스트의 힘
## 일반 텍스트?
- 인쇄 가능한 문자로 이루어짐
- **정보를 전달**하기에 적합한 형식을 갖추어야 함
- 사람이 이해할 수 있어야 한다.

### Tip 25. 지식을 일반 텍스트로 저장하라.

## 텍스트의 힘

### 텍스트를 사용하는 이유:
- 지원 중단에 대한 보험
    - 특별한 형식이 존재할 경우, 문자열 속 의미를 쉽게 깨닫을 수 없을 것이다.
    - 사람이 **읽을 수 있는 것**과 사람이 **이해할 수 있는 것**에는 차이가 있다.
- 기존 도구의 활용
    - 버전 관리 시스템, 에디터, 명령 줄 도구 등 컴퓨터 속 모든 도구에서 일반 텍스트를 다룰 수 있다.
    - 호환성이 좋다.
- 더 쉬운 텍스트
    - 시스템 테스트에 사용할 합성 데이터를 일반 텍스트로 표현하면 **특별한 도구를 만들 필요 없이** 간단하게 테스트 데이터를 추가하거나 수정할 수 있다.

### cf. 유닉스 철학
- 작고 예리한 각각의 도구가 한 가지 일만 잘하도록 만들자는 철학에 따라 설계: 줄 단위로 처리하는 일반 텍스트 파일을 기반 포맷으로 공유하기 때문에 가능
- 시스템 관리용 데이터베이스(사용자, 비밀번호, 네트워크 설정 등)를 모두 일반 텍스트 파일로 저장한다.
- 일반 텍스트는 검색도 쉽다.

### 최소 공통분모
- 미래 시대에도 텍스트 파일은 어디에나 존재한다.
- 모든 참가자가 하나의 공통 표준을 사용하여 소통하도록 해야되고, 그 표준은 바로 "일반 텍스트"가 될 것이다.

# Topic 17. 셸 가지고 놀기
- 프로그래머에게는 **명령어 셸**이 모든 종류의 도구를 불러다 쓸 수 있는 작업대와 같다.
- GUI와 IDE는? 모두 똑같이 잘할 수 있는 게 아닌가?
    - 답은 **No.**
    - 모든 작업을 GUI대로만 하면 우리가 가진 환경의 능력을 전부 이용할 수 없다.
    - WYSIWYG는 GUI의 장점이자 단점이 된다.
    - 일반적으로 설계자가 의도한 범위를 넘어설 수 없다!
- 셸의 가장 큰 장점: 급상승하는 생산성
    - 자바 코드에서 명시적으로 import하는 패키지 이름을 중복 없이 보아야한다면?
    ```sh
    grep '^import ' *.java | \
        sed -e 's/.*import *//' -e's/;.*$//' | \
        sort -u > list
    ```
### Tip 26. 명령어 셸의 힘을 사용하라.

## 자신만의 셸
- 개발자는 셸을 자신에게 맞추어야 한다.
### 조합 설정
1. 색깔 조합 설정
2. 프롬포트 설정
    - 보통 프롬포트의 기능은 '셸이 입력을 받을 준비가 되었음을 알리는 것'이지만, 원하는 정보를 추가로 표현할 수 있다.
3. 별칭(alias)과 셸 함수
    - ex. 리눅스에서 패키지들을 정기적으로 업데이트할 때 순서가 헷갈린다면 다음과 같이 별칭을 만들어라: `alias apt-up = 'sudo apt-get update && sudo apt-get upgrade'`
    - ex. rm 명령어를 사용하여 파일을 지우는 실수를 자주 겪는다면, 다음과 같이 별칭을 만들어라: `alias rm = 'rm -iv'`
4. 명령어 자동 완성
    - 대부분의 셸은 명령어와 파일명 자동 완성을 지원한다.

# Topic 18. 파워 에디팅
- 1판에서는 하나의 에디터로 모든 작업을 하라고 추천했으나... 시대가 바뀌었다! 원한다면 다양한 에디터를 사용해도 좋은데, 유창해지도록 노력해야 한다.

### Tip 27. 에디터를 유창하게(fluency) 쓸 수 있게 하라.
- 이유
    - 시간을 많이 절약할 수 있어서
    - 더는 에디터 사용법을 생각하지 않아도 되서 (생각이 자유롭게 흐를 것이라고 믿는다)

## 유창함(fluency)이란 무엇인가?
- 다음 과제에 도전해보자:
    - 텍스트를 편집할 때 문자, 단어, 줄, 문단 단위로 커서를 이동하거나 내용을 선택하라.
    - 코드를 편집할 때 반대쪽 괄호로 이동하거나, 함수, 모듈 등 다양한 문법 단위로 커서를 이동하라.
    - 변경한 코드의 들여쓰기(indent)를 자동으로 맞춰라.
    - 여러 줄의 코드를 명령 하나로 주석 처리했다가 다시 주석을 해제하라.
    - 실행 취소를 여러 번 했다가 취소한 명령을 재실행 기능으로 다시 수행하라.
    - 에디터 창을 여러 구역으로 쪼개라. 그리고 각 구역 사이를 이동하라.
    - 특정 줄 번호로 이동하라.
    - 여러 줄을 선택한 후 가나다순으로 정렬하라.
    - 문자열로, 또 정규 표현식으로 검색하라. 이전에 검색했던 것을 다시 검색하게 하라.
    - 선택 영역이나 패턴 검색을 이용, 일시적으로 여러 개의 커서를 만든 다음, 동시에 여러 곳의 텍스트를 편집하라.
    - 현재 프로젝트의 컴파일 오류를 표시하라.
    - 현재 프로젝트의 테스트를 실행하라.

## 유창해지기
- 당연히 **모든** 명령어를 외우고 있는 사람은 손에 꼽는다.
- 대신 삶을 편하게 해 주는 명령어를 배우자!
- 에디터를 사용할 때, '분명 더 나은 방법이 있을 텐데'라고 생각하는 습관을 들여라.
- 유용한 기능을 찾았다면 몸이 기억하도록 반복하자.

## 에디터 성장시키기
- 사용중인 에디터에서 명백한 한계에 봉착한다면 필요한 기능을 추가하는 확장 기능을 찾아보자.
- 사용하는 에디터의 확장 기능 언어를 파헤쳐 보라. 자동화할 방법을 연구해 보자.
- 때로는 멀리 나아가서 확장 기능을 만들어낼 수도 있을 것이다. 그렇다면 공개하자!

### 도전해 볼 것
- 자동 반복 기능을 끄자.
- 그와 관련된 단축키를 배우자.
- 마우스나 트랙패드를 치워라 (!!)
- 여러분이 하는 일을 에디터에 통합하는 방법을 찾아라.
- 여러분이 원하는 일을 하는 플러그인이나 확장 기능을 찾을 수 없다면 하나 만들어 보자. (!!!)

# Topic 19. 버전 관리
> 진보란 것은 변화와 거리가 멀고 오히려 기억에 의존한다. 과거를 기억하지 못하는 사람은 과거를 반복할 운명이다. -조지 산타야나

### 공유 디렉터리는 버전 관리 시스템이 아니다.
- 프로젝트 소스 파일을 단순하게 네트워크로 공유하는 팀이 아직도 가끔씩 존재한다.
- 이건 지속 불가능한 짓이다. 버전 관리를 사용하라.

## 버전 관리에 대해 살펴보자.

## 소스 코드부터 시작
- 버전 관리 시스템은 소스 코드, 문서의 모든 변경 사항을 기억한다.
- 언제든지 소프트웨어의 이전 버전으로 되돌아갈 수 있다.
- 버그 추적, 감사(audit), 성능 관리, 품질 관리를 해야 할 때 매우 귀중하다.
- VCS를 사용하면 소프트웨어의 특정 릴리스를 찾아 언제든지 재생산해 낼 수 있다.
- VCS를 사용하면 둘 이상의 사용자가 동일한 파일들을 동시에 작업할 수 있다.

### Tip 28. 언제나 버전 관리 시스템을 사용하라.
- **모든 것**을 버전 관리 아래에 둬라.

## 브랜치 사용하기
- 브랜치: 개발 중인 내용을 섬처럼 따로 떼어 격리하는 기능
- 브랜치에서 작업한 내용은 다른 브랜치로부터 **격리**되지만, 작업한 브랜치를 나중에 다른 브랜치로 **병합**할 수도 있다.
- 브랜치가 팀의 프로젝트 업무 흐름에서 핵심이 되는 경우가 많다.

## 프로젝트 허브로서의 버전 관리
- 버전 관리는 팀에서 사용할 때 진가가 드러난다.
- 저장소 시스템에서 필요한 내용
    - 확실한 보안과 권한 관리
    - 직관적인 UI
    - 명령 줄에서도 모든 작업 수행 가능
    - 자동화된 빌드와 테스트
    - 브랜치 병합을 잘 지원
    - 이슈 관리
    - 적절한 보고서 기능
    - 원활한 팀 의사소통을 돕는 기능


# Topic 20. 디버깅
> 참으로 고통스러운 일입니다. 자신이 겪는 어려움을 보고는 알게 되죠. 다른 누구도 아닌 바로 자신이 문제를 만들었다는 걸. - 소포클레스
- 버그: 14세기 이해 공포의 대상을 지칭하는 용어 (흥미롭구만!)
- 컴퓨터 시스템은 여러분이 **명령하는 것**을 할 뿐, 여러분이 **원하는 것**을 알아서 하지 않는다.
- 디버깅에 관련된 문제와 버그를 찾아내는 일반적인 전략을 알아보자.

## 디버깅의 심리
- 디버깅은 단지 문제 풀이다.
- 남을 비난하기보다는 문제를 고치는 데에 집중해야 한다.
- 버그가 누구의 잘못인지는 중요치 않으나 그 버그를 해결해야 하는 사람은 바로 나다.

### Tip 29. 비난 대신 문제를 해결하라.

## 디버깅 사고 방식

### Tip 30. 디버깅 제 1 법칙: 당황하지 말라.

- '하지만 정말 그럴 리가 없는데'로 시작하는 생각의 흐름에 집중하라.
- 디버깅할 때 근시안의 함정에 주의하라. 실제 문제는 몇 단계 떨어져 있고, 또 다른 문제와 연관되어 있을 확률이 다분하다.
- 문제의 근본 원인을 찾으려고 노력하라.

## 실마리 찾기
- 버그를 살펴보기 전에, 작업 중인 코드가 깨끗하게 빌드되는지부터 확인하라.
- 처음에 받은 자료 이상을 위해 버그를 보고한 사용자를 인터뷰할 필요가 있다.
- 인공적인 테스트는 애플리케이션을 충분히 테스트하지 못한다. 경계 조건과 실제 최종 사용자의 사용 패턴 모두를 철저히 체계적으로 테스트할 필요가 있다.

## 디버깅 전략
- 프로그램은 어떻게 생각하는지 알아내보자.

### 버그 재현하기: Tip 31. 코드를 고치기 전 실패하는 테스트부터.

### 미지의 세계에 온 프로그래머
- 문제가 무엇인지 좀 보자.

### Tip 32. 그놈의 오류 메세지 좀 읽어라.

### 이상한 결과
1. 디버거에 잘못된 값이 나타나는지 확인하라.
2. 메모를 하면서 손버깅(...)을 하면 도움이 될 것이다.
3. 흔한 버그 시나리오 두 가지를 살펴보자:
    - 입력값에 따라 바뀜: 어떤 입력값이 어떤 원인인지를 파악하라.
    - 릴리스 사이에서 발생한 문제:이진 분할이 나타날 타이밍이다.

### 이진분할
- 정확히 어떤 함수에서 문제가 되는 값을 엉망으로 만들었는지 찾아내기 위해서... 순서대로 스택 프레임을 골라 값이 정상인지 확인 후 이진 분할을 반복하자.
- 특정 데이터 세트에 대해서만 버그가 나타나는 경우: 데이터 세트를 둘로 나눠 이진 분할을 반복하자.

### 로깅과 트레이싱
- 트레이싱(tracing) 구문: 작은 진단용 메시지(ex. '여기까지 도달', 'x값= 2')
- 주의: 트레이싱 구문으로 남기는 메시지는 규칙적이고 일관적이어야 한다.

### 고무오리
- 문제의 원인을 찾는 매우 단순한 기법: 누군가에게 문제를 설명해보라.

### 소거법 
- 대게 애플리케이션 코드에 버그가 존재할 가능성이 크다.
- 외부 제품에 문제가 있더라도 버그 리포트를 제출하기 전 코드에 문제가 없음을 확인해야 한다.

### 놀라운 구석: Tip 34. 가정하지 말라. 증명하라.
- 버그와 관련된 루틴이나 코드가 제대로 작동한다는 걸 '안다'고 해서 대충 얼버무리고 지나치지 말라. 
- 코드를 '안다는' 사실을 증명하라. 이 맥락 안에서, 이 데이터로, 이 경계 조건 하에서.
- 어떤 일이 일어났든지 간에 똑같은 일이 다시 발생하면 그 사실을 알 수 있도록 하라.

## 디버깅 체크 리스트
1. 보고된 문제가 내재하는 버그의 직접적 결과인가 아니면 단순히 증상일 뿐인가?
2. 버그가 정말로 여러분이 사용하는 프레임워크에 있나? OS에? 아니면 여러분 코드에 있나?
3. 이 문제를 동료에게 상세히 설명한다면 어떻게 말하겠는가?
4. 의심 가는 코드가 단위 테스트를 통과한다면 테스트는 충분히 갖춰진 것인가? 이 데이터로 테스트를 돌리면 무슨 일이 생기는가?
5. 이 버그를 야기한 조건이 시스템의 다른 곳에도 존재하는가? 다른 버그가 유충 단계서 성충이 될 날만 기다리고 있는 것은 아닌가?

# Topic 21. 텍스트 처리
- 가끔은 기본 도구만으로는 해내기 힘든 종류의 변환 작업이 있다. 범용 텍스트 처리 도구가 필요한 것이다.
- 뭔가를 재빨리 원하는 모양으로 잘라 내거나, 연결 부위를 만들고, 깎아 낼 수 있다.
- 훌륭한 텍스트 처리 언어가 많이 있다: 명령어 셸, 파이썬, 루비 등
- 중요한 기반 기술(enabling technology): 유틸리티를 만들어낼 수도 있고, 아이디어를 프로토타입해 볼 수도 있다. 
### Tip 35. 텍스트 처리 언어를 익혀라.

### 연습 문제
1. 연습 문제 11
> 여러분은 설정 파일에 yaml 형식을 사용했던 애플리케이션을 다시 쓰고 있다. 여러분의 회사가 JSON을 쓰기로 표준을 정했기 때문에 수많은 파일을 .json 파일로 바꾸어야 한다. 디렉터리를 인자로 받아서 그 안의 .yaml 파일들을 각각 그에 해당하는 .json 파일로 바꾸는 스크립트를 작성하라. 예를 들어, database.yaml은 database.json이 되고, 파일의 내용은 json 문법을 따라야 한다.

2. 연습 문제 12
> 여러분의 팀은 원래 변수 이름에 낙타 표기법을 사용했으나 단체로 마음을 고쳐 먹고 뱀 표기법으로 바꾸기로 했다. 모든 소스 파일을 검사하여 낙타 표기법을 사용하는 부분을 찾아내는 스크립트를 만들어라.

3. 연습 문제 13
> 앞 문제에서 이어지는 문제다. 낙타 표기법을 찾아내는 데서 그치지 말고 변수 이름을 여러 파일에서 자동으로 바꿔주는 기능을 추가하라. 끔찍한 일이 벌어질 수도 있으니 변경한 파일의 백업을 만드는 것을 잊지 말라.

# Topic 22. 엔지니어링 일지


## 일지를 쓰면 좋은 점:
- 기억보다 더 믿을 만하다.
- 진행 중인 작업과 직접적인 관계가 없는 발상을 일단 쌓아 놓을 수 있는 곳이 생ㅇ긴다.
- 고무 오리와 같은 역할을 할 수도 있다.

## 엔지니어링 일지를 남겨 보자. 
- 파일이나 위키 말고 종이를 사용하라. 


**오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어 보세요.**

- 예전에 같은 학과 선배 혹은 외부 컨퍼런스에서 개발자라면 당연히 mac을 써야 한다는 말을 얼핏 들었던 기억이 난다. 그때만 하더라도 구직중이었던 지친 어린 양은 '애플이라는 이름값 만으로도 사람을 잘나가는 개발자처럼 보일 수 있게 하는 걸까?'라는 삐딱한 질문을 마음 속으로만 했더랬다. 그리고 오늘. 뜬금없게도 topic 17 <셸 가지고 놀기>를 보며 (...) 철없던 지난 날의 나를 다시금 떠올렸다. 부끄럽지만 다시 그때로 돌아간다면 나에게 조용히 속삭여주고 싶다. "제발 이상한 생각하지 말고 실용주의 프로그래머 책이나 읽어라."

- 실용주의 프로그래머 책을 읽으며 대부분 개발자 생활의 바이블과도 같은 느낌으로 글을 읽었으나, 마지막 Topic 22 <엔지니어링 일지>를 보며 이견을 느꼈다. 당연히 엔지니어링 일지를 "써야 한다."는 말에는 동의를 한다. 그러나 "파일이나 위키 말고 종이를 사용하라"는 입장에는 반대하는 편.
- 나는 입사 이래로 에버노트, 노션을 이용하여 <엔지니어링 일지>를 작성했다. (물론 이제 사담을 충실히 곁들인.) 장점은 누군가에게 업무에 관해 커뮤니케이션을 할 때 나름 깔끔하게 정리된 문서(=일지)를 가지고 사용할 수 있어 편리했다는 점이었다. 게다가 "온라인"으로도 충분히 소통이 가능하다는 점이 편했다. 바쁘다 바빠 현대사회에서는 하드 카피로 작성한 문서에 대해 소프트 카피로 변환하는 시간조차 부족하다. (특히 이제 연차가 차오를수록 정성들여 정리하는 것은 더더욱 불가능하다. 간략한 내용은 적되 필수불가결한 내용은 노션에 정리한다.) 만약 오늘 파트를 읽고 엔지니어링 일지에 대해 고민한다면 개인적으로 노션을 추천한다. 
- 아, 덧붙이자면 나의 경우 엔지니어링 일지를 편히 외부 프로그램인 노션을 사용할 수 있는 환경에서 업무를 할 수 있었다. 만약 이것이 불가능하다면 최대한 markdown을 작성하는 방법에 대해 터득하여 vsc로 markdown 문서를 작성해보자. vsc에서는 markdown 문서를 ppt로도 내보내주는 아주 어마어마하고 무시무시한 기능을 갖추고 있다.

**궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어 보세요.**

- 대부분 술술 읽히기에 특별히 궁금한 내용이 존재하지는 않았지만, 개인적으로는 셸 언어가 그렇게 강력한지 진짜 경험해보고 싶어졌다. 특히 "시스템 정보를 버전 관리 시스템으로 관리하여 빠른 복구가 가능했다."는 부분에 이끌려.. 먼지가 쌓인 맥북을 켜고 <자신만의 셸> 부분을 다시 읽어야 겠다.

**오늘 읽은 다른 사람의 TIL**
- @jds9285 님 https://nomadcoders.co/community/thread/3895 : 적절한 드립.. 매력 있으시다.
